# The AI Native Software Engineer

Software engineering did not disappear.

It evolved.

When intelligence becomes programmable, the bottleneck is no longer code.
It is clarity.

This repository defines a disciplined methodology for building software in the age of large-scale coding models.

It is not a collection of prompts.
It is not a tool comparison.
It is not a shortcut to building complex systems.

It is a framework.

---

## What This Is

A structured lifecycle for:

- Turning a problem into a validated MVP
- Scaling it in controlled phases
- Preventing architectural drift
- Using AI as leverage without losing rigor
- Maintaining long-term system durability

The framework is tool-agnostic.

Models will evolve.
Tooling will change.
The discipline remains.

---

## Who This Is For

This is for engineers who:

- Already understand software fundamentals
- Care about structure and long-term maintainability
- Want to use AI without sacrificing engineering standards
- Refuse to delegate thinking

This is not about “vibe coding.”
It is about disciplined problem solving.

---

## The Lifecycle

The methodology consists of five phases:

1. **Identify the Problem**  
   Replace enthusiasm with structured clarity.

2. **Translate to a Structured Plan**  
   Convert clarity into a phased execution roadmap.

3. **Establish the Foundation**  
   Create a controlled and versioned execution environment.

4. **Controlled Implementation**  
   Build in bounded, validated increments.

5. **Structured Improvement**  
   Strengthen durability without expanding scope.

Full overview:  
→ `framework-overview.md`

---

## Context Discipline

The primary structural risk in AI-assisted engineering is context rot.

Long sessions degrade coherence.
Unmanaged context introduces architectural drift.

This framework treats context control as a first-class discipline.

See:  
→ `context-discipline.md`

---

## Core Artifacts

Every project following this framework should contain:

- `docs/plan.md`
- `docs/progress.md`
- `docs/project-guidelines.md`
- `docs/technical-debt.md`

Conversation is transient.
Artifacts are durable.

---

## Abstraction First

This framework separates concepts from tooling.

See:  
→ `concept-to-implementation.md`

Concepts are stable.
Implementations evolve.

---

## Governing Principles

Across all phases:

- Specification precedes implementation.
- Constraints precede generation.
- Verification precedes merge.
- Clarity precedes speed.
- Ambiguity compounds.
- Structure scales.

The cost of code decreases.
The cost of unmanaged context increases.

---

Engineering remains discipline.

Clarity remains leverage.